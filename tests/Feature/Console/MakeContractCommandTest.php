<?php

declare(strict_types=1);

use Illuminate\Filesystem\Filesystem;
use Illuminate\Support\Facades\Artisan;

it('creates a Domain Contract with methods and imports', function (): void {
    $fs = new Filesystem();

    $module = 'Planner';
    $contractsBase = base_path("modules/{$module}/Domain/Contracts");
    $fs->ensureDirectoryExists($contractsBase);

    $target = base_path("modules/{$module}/Domain/Contracts/TripRepositoryContract.php");

    if ($fs->exists($target)) {
        $fs->delete($target);
    }

    // Compose methods spec featuring Ulid, union types, FQCN param
    $methods = 'findById:Modules\\Planner\\Domain\\DTO\\TripData|null(id:Ulid); create:string(data:Modules\\Planner\\Domain\\DTO\\CreateTripData)';

    $exit = $this->artisan('ddd-lite:make:contract', [
        'module' => $module,
        'name' => 'TripRepository',
        '--methods' => $methods,
    ])->run();

    expect($exit)->toBe(0)
        ->and($fs->exists($target))->toBeTrue();

    $code = (string) $fs->get($target);

    // Namespace and interface declaration
    expect($code)
        ->toContain('namespace Modules\\Planner\\Domain\\Contracts;')
        ->toContain('interface TripRepositoryContract');

    // Imports must include Ulid and FQCNs referenced
    expect($code)
        ->toContain('use Symfony\\Component\\Uid\\Ulid;')
        ->toContain('use Modules\\Planner\\Domain\\DTO\\TripData;')
        ->toContain('use Modules\\Planner\\Domain\\DTO\\CreateTripData;');

    // Method signatures normalized: class basenames in signature, union retained
    expect($code)
        ->toContain('public function findById(Ulid $id): TripData|null;')
        ->toContain('public function create(CreateTripData $data): string;');
});

it('supports dry-run without writes', function (): void {
    $fs = new Filesystem();

    $module = 'Planner';
    $contractsBase = base_path("modules/{$module}/Domain/Contracts");
    $fs->ensureDirectoryExists($contractsBase);

    $target = base_path("modules/{$module}/Domain/Contracts/OrderContract.php");
    if ($fs->exists($target)) {
        $fs->delete($target);
    }

    $exit = $this->artisan('ddd-lite:make:contract', [
        'module' => $module,
        'name' => 'Order',
        '--dry-run' => true,
    ])->run();

    expect($exit)->toBe(0)
        ->and($fs->exists($target))->toBeFalse();
});

it('supports force overwrite and creates backups (and optional fake/test)', function (): void {
    $fs = new Filesystem();

    $module = 'Planner';
    $contractsBase = base_path("modules/{$module}/Domain/Contracts");
    $fs->ensureDirectoryExists($contractsBase);

    $name = 'PaymentGateway';
    $target = base_path("modules/{$module}/Domain/Contracts/{$name}Contract.php");

    // Seed file so we can detect overwrite and backup
    $fs->put($target, "<?php\n// original\n");

    $exit = $this->artisan('ddd-lite:make:contract', [
        'module' => $module,
        'name' => $name,
        '--methods' => 'charge:string(amount:int); refund:bool(txnId:string)'.'',
        '--with-fake' => true,
        '--force' => true,
    ])->run();

    expect($exit)->toBe(0)
        ->and($fs->exists($target))->toBeTrue();

    $code = (string) $fs->get($target);
    expect($code)->toContain('interface PaymentGatewayContract');

    // Backup directory must exist due to overwrite
    $backupDir = base_path('storage/app/ddd-lite_scaffold/backups');
    expect($fs->exists($backupDir))->toBeTrue();

    // Fake should be generated when requested
    $fakePath = base_path("modules/{$module}/tests/Unit/fakes/{$name}Fake.php");
    expect($fs->exists($fakePath))->toBeTrue();

    $fakeCode = (string) $fs->get($fakePath);
    expect($fakeCode)
        ->toContain('namespace Modules\\Planner\\tests\\Unit\\fakes;')
        ->toContain('final class PaymentGatewayFake implements PaymentGatewayContract');

    // Test file should be generated by default when not suppressed
    $testPath = base_path("modules/{$module}/tests/Unit/Domain/Contracts/{$name}ContractTest.php");
    expect($fs->exists($testPath))->toBeTrue();
});

it('is idempotent when no changes are needed', function (): void {
    $fs = new Filesystem();

    $module = 'Planner';
    $contractsBase = base_path("modules/{$module}/Domain/Contracts");
    $fs->ensureDirectoryExists($contractsBase);

    $name = 'Inventory';
    $target = base_path("modules/{$module}/Domain/Contracts/{$name}Contract.php");

    if ($fs->exists($target)) {
        $fs->delete($target);
    }

    // First create
    $exit1 = $this->artisan('ddd-lite:make:contract', [
        'module' => $module,
        'name' => $name,
        '--methods' => 'exists:bool(id:string)',
    ])->run();

    expect($exit1)->toBe(0);
    $original = $fs->exists($target) ? (string) $fs->get($target) : '';

    // Second run without --force, unchanged
    $exit2 = $this->artisan('ddd-lite:make:contract', [
        'module' => $module,
        'name' => $name,
        '--methods' => 'exists:bool(id:string)',
    ])->run();

    expect($exit2)->toBe(0);
    $after = $fs->exists($target) ? (string) $fs->get($target) : '';
    expect($after)->toBe($original);
});

it('skips test generation when --no-test is passed and supports rollback by manifest id', function (): void {
    $fs = new Filesystem();

    $module = 'Planner';
    $contractsBase = base_path("modules/{$module}/Domain/Contracts");
    $fs->ensureDirectoryExists($contractsBase);

    $name = 'EmailService';
    $target = base_path("modules/{$module}/Domain/Contracts/{$name}Contract.php");

    if ($fs->exists($target)) {
        $fs->delete($target);
    }

    // Create with --no-test and capture manifest id
    $exitCreate = Artisan::call('ddd-lite:make:contract', [
        'module' => $module,
        'name' => $name,
        '--methods' => 'send:void(to:string, body:string)',
        '--no-test' => true,
    ]);

    expect($exitCreate)->toBe(0);

    $output = Artisan::output();
    preg_match('/Manifest:\s+([a-f0-9\-]+)/i', $output, $m);
    expect($m)->toHaveCount(2);
    $manifestId = $m[1];

    // Ensure contract exists and test does not
    $testPath = base_path("modules/{$module}/tests/Unit/Domain/Contracts/{$name}ContractTest.php");
    expect($fs->exists($target))->toBeTrue()
        ->and($fs->exists($testPath))->toBeFalse();

    // Rollback using captured manifest id
    $exitRollback = Artisan::call('ddd-lite:make:contract', [
        'module' => $module, // ignored during rollback
        'name' => $name,     // ignored during rollback
        '--rollback' => $manifestId,
    ]);

    expect($exitRollback)->toBe(0)
        ->and($fs->exists($target))->toBeFalse();
});
